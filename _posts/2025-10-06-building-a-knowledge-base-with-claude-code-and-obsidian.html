---
layout: post
title: "Building a Knowledge Base with Claude Code and Obsidian"
date: 2025-10-06 12:00:00 +0200
slug: building-a-knowledge-base-with-claude-code-and-obsidian
tags: [claude-code, codex, obsidian, knowledge-management, ai-agents, note-taking, devtools]
keywords: [claude code, CLAUDE.md, slash commands, subagents, Obsidian, knowledge base, Codex CLI, developer notes]
description: "How I use Claude Code slash commands, subagents, and Obsidian to capture task notes and grow a durable knowledge base—plus a Codex CLI bridge."
canonical: https://blog.acascais.com/building-a-knowledge-base-with-claude-code-and-obsidian/
image: /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/slash_command_namespace.png
permalink: /building-a-knowledge-base-with-claude-code-and-obsidian/
---
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#claude-md-slash-commands-and-agents">CLAUDE.md, slash commands, and agents</a>
  <ul>
    <li><a href="#claude-md-hierarchy">CLAUDE.md hierarchy</a></li>
    <li><a href="#custom-slash-commands">Custom slash commands</a>
      <ul>
        <li><a href="#namespacing-and-folders">Namespacing and folders</a></li>
      </ul>
    </li>
    <li><a href="#customizing-agents">Customizing agents</a></li>
  </ul>
</li>
<li><a href="#notes-writer-and-knowledge-curator">Notes writer and knowledge curator</a>
  <ul>
    <li><a href="#task-notes">Task notes</a>
      <ul>
        <li><a href="#user-context-command">/user:context command</a></li>
      </ul>
    </li>
    <li><a href="#knowledge-base-curator-flow">Knowledge base curator flow</a></li>
  </ul>
</li>
<li><a href="#obsidian-integration">Obsidian integration</a></li>
<li><a href="#codex-cli-bridge">Codex CLI bridge</a>
  <ul>
    <li><a href="#limitations">Limitations</a></li>
  </ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</nav>

<h2 id="tldr">TL;DR</h2>
<div style="background-color: #f5f5f5; border-left: 4px solid #2c3e50; padding: 1rem 1.5rem; margin: 1.5rem 0;">
  <p><strong>TL;DR:</strong> I configured Claude Code and Codex CLI to act as my personal knowledge management system. Using <strong>CLAUDE.md</strong> files, <strong>custom slash commands</strong>, and <strong>agents</strong>, I automate note-taking during tasks and curate a searchable knowledge base visualized with <strong>Obsidian</strong>.</p>
  <p><strong>Key benefits:</strong></p>
  <ul style="margin-bottom: 0.5rem;">
    <li>Context persistence across AI sessions</li>
    <li>Task notes automatically capture what matters</li>
    <li>Knowledge base grows organically from your work</li>
    <li>Works with both Claude Code and Codex CLI (with some work-arounds) via shared config</li>
  </ul>
  <p><strong>Get the code:</strong> <a href="https://github.com/antoniocascais/claude-code-knowledge" target="_blank">Claude Code knowledge repo</a></p>
</div>

<div class="prerequisites" style="background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 4px; padding: 0.75rem 1rem; margin: 1.5rem 0; font-size: 0.9rem;">
  <strong>Prerequisites:</strong>
  <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
    <li>Claude Code v2.0.5 or Codex CLI v0.42.0</li>
    <li>Obsidian v1.9.14</li>
    <li>Folder locations: <code>$HOME/.claude</code>, <code>$HOME/.codex</code></li>
  </ul>
  <hr style="border: none; border-top: 1px dashed #ddd; margin: 0.75rem 0;">
  <p style="margin: 0;">
    <strong>Tested with:</strong>
    Claude Code v2.0.5 · Codex CLI v0.42.0 · Obsidian v1.9.14 · OS: Linux
    <span style="opacity: 0.8;">(as of 2025-10-06)</span>
  </p>
</div>

<section id="intro">
<h2>Intro</h2>

<p>A couple months ago I saw <a href="https://x.com/mckaywrigley" target="_blank">McKay Wrigley</a> talking about how he was using Claude Code to write notes and build a knowledge base that can be navigated via <a href="https://obsidian.md/" target="_blank">Obsidian</a>. </p>
<p>The idea sounded good to me, so I thought &quot;why don&#39;t I try the same?&quot;. After building it and using it for a couple months, I have to say I&#39;m happy about it and the approach has helped me quite a bit.</p>
<p>In this article I&#39;ll explain how I configured my setup and how I refactored it to be compatible with both <a href="https://docs.claude.com/en/docs/claude-code/overview" target="_blank">Claude Code</a> and <a href="https://developers.openai.com/codex/cli" target="_blank">Codex CLI</a>.</p>
<p>At the end of the article, you can see the link to the public GitHub repo in which I keep my CLAUDE.md, AGENTS.md and other relevant files.</p>

</section>

<h2 id="claude-md-slash-commands-and-agents">CLAUDE.md, slash commands, and agents</h2>
<h3 id="claude-md-hierarchy">CLAUDE.md hierarchy</h3>
<p>Claude Code can be customized via <code>CLAUDE.md</code> files. These are "memory"/instructions files that Claude automatically loads. In Linux, the main one is stored under <code>/etc/claude-code/CLAUDE.md</code> and can be extended/overridden by project files in the current repo (e.g., <code>./CLAUDE.md</code> or <code>./.claude/CLAUDE.md</code>) and/or by a user file in your home folder (<code>$HOME/.claude/CLAUDE.md</code>). </p>
<p>Basically, Claude Code loads the <code>CLAUDE.md</code> files in a hierarchical structure:</p>
<ol>
<li>Enterprise policy in <code>/etc/claude-code/CLAUDE.md</code> (for Linux users, if present);</li>
<li>Project memory in <code>./CLAUDE.md</code> or <code>./.claude/CLAUDE.md</code>;</li>
<li>User memory in <code>$HOME/.claude/CLAUDE.md</code>.</li>
</ol>
<p>Important note: <code>CLAUDE.md</code> guides behavior. Actual configuration (e.g., MCP servers, permissions) lives in <code>settings.json</code> files (with a similar - but not the same - hierarchical structure).</p>
<h3 id="custom-slash-commands">Custom slash commands</h3>
<p>Claude Code offers a couple of slash commands by default (e.g., <code>/context</code>, <code>/config</code>, <code>/memory</code>) and also allows users to define custom slash commands.</p>
<p>The custom slash commands are nothing more than prompts, which means you should use them to define frequently-used prompts.</p>
<p>For example, if you often ask Claude Code to review your git diff taking into consideration security aspects, naming standards, etc., instead of writing that long prompt every time you can just save it in <code>$HOME/.claude/commands/git_diff_review.md</code> (or, if you want the prompt specific per project, save the file under <code>./.claude/commands/</code>) and then call it by using <code>/git_diff_review</code> inside Claude Code.</p>
<p>You can also pass arguments to the command (e.g., <code>/git_diff_review only staged files</code>) and reference them with <code>$ARGUMENTS</code>.</p>
<p>If in your <code>git_diff_review.md</code> you have something like</p>
<pre><code>Do a git diff and follow the instructions $ARGUMENTS [...]
</code></pre>
<p>It becomes</p>
<pre><code>Do a git diff and follow the instructions only staged files [...]
</code></pre>
<h4 id="namespacing-and-folders">Namespacing and folders</h4>
<p>You can also organize your custom slash commands per folder. This helps in case you have multiple slash commands with the same name (e.g., the default <code>/context</code> and a custom <code>/user:context</code>) or if you want to have different slash commands per context (e.g., <code>/git:review</code> for code reviews and <code>/docs:review</code> for review on documentation).</p>
<p>Taking into consideration these examples, the folder structure would be (assuming we are only using commands in the home folder):</p>
<pre><code>$ tree commands/
commands/
├── docs
│   └── review.md
├── git
│   └── review.md
├── my_awesome_command.md
└── user
    └── context.md
</code></pre>
<p>As you&#39;ll see later, I use the <code>user:context</code> slash command: it&#39;s stored in a <code>user</code> folder and it&#39;s done like this to avoid conflicts with the default <code>/context</code> slash command:</p>
<p><picture>
<source type="image/avif" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/slash_command_namespace-800.avif 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/slash_command_namespace-1200.avif 1200w">
<source type="image/webp" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/slash_command_namespace-800.webp 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/slash_command_namespace-1200.webp 1200w">
<img src="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/slash_command_namespace.png" width="952" height="180" loading="lazy" decoding="async" sizes="(max-width: 800px) 100vw, 800px" alt="Claude Code showing /context and /user:context slash commands.">
</picture></p>
<h3 id="customizing-agents">Customizing agents</h3>
<p>Note: even though the docs call them &quot;subagents&quot;, in this post we are referring them as agents because the command to create them is <code>/agents</code>.</p>
<p>According to <a href="https://docs.claude.com/en/docs/claude-code/sub-agents" target="_blank">Claude Code official documentation</a>, &quot;Subagents are pre-configured AI personalities that Claude Code can delegate tasks to.&quot;.</p>
<p>Each agent has its own specification (as in, custom system prompt), purpose, allowed tools it can use (if necessary) and, very important, its own context window.</p>
<p>Agents can be defined as <em>Markdown</em> files in <code>.claude/agents/</code> folder (similar to before, the order is your current project -&gt; your home folder).</p>
<p>You can create/edit an agent by calling <code>/agents</code> or manually edit the file if necessary. The agents file format can be found <a href="https://docs.claude.com/en/docs/claude-code/sub-agents#file-format" target="_blank">here</a>.</p>
<p>Once the agent is created, you can tell Claude Code to use it. Sometimes, Claude Code also proactively calls the agent (based on the agent description and current task context).</p>
<p>For best practices, please read the <a href="https://docs.claude.com/en/docs/claude-code/sub-agents#best-practices" target="_blank">official documentation</a>.</p>
<h2 id="notes-writer-and-knowledge-curator">Notes writer and knowledge curator</h2>
<p>When we work in a task, we get knowledge on the topic: how tool xyz works, how the architecture of our project is designed, the details on why we had to configure something that way, etc.</p>
<p>While I was working on tasks with Claude Code, I realized we can take advantage of all the context in the Claude Code conversation and write down all the knowledge we acquired while doing the task.</p>
<p>So I decided to configure Claude Code to take notes on the tasks we are doing and also to write down more advanced knowledge base documents.</p>
<h3 id="task-notes">Task notes</h3>
<p>Having Claude Code taking notes on the tasks we are working on works great for me due to multiple reasons:</p>
<ul>
<li>it helps me keep track of the task progress (what&#39;s done, what&#39;s ongoing, what needs to be done);</li>
<li>it records important information about the task (for example, <em>we need to provision this pod with 512 MiB requested memory because it has spikes during cronjob runs</em>);</li>
<li>and, my favourite feature, it&#39;s a great way to give context to Claude Code!</li>
</ul>
<p>I think it&#39;s important to expand more on the last point above: by &quot;giving context&quot; to Claude Code I mean we can start a Claude Code with the correct task context. We just need to tell it to search in its notes for the topic we want to work on, and then Claude Code &quot;loads&quot; already with the correct information.</p>
<p>An important detail on how I configured the task notes: I don&#39;t care what Claude Code writes there. This is on purpose, to mimic how I would work with a human: it&#39;s their notes, I don&#39;t review them.</p>
<p>This is explicitly stated in <a href="https://github.com/antoniocascais/claude-code-knowledge/blob/main/CLAUDE.md.example" target="_blank">CLAUDE.md</a>:</p>
<pre><code>- Task notes are for Claude&#39;s use only
</code></pre>
<h4 id="user-context-command"><code>/user:context</code> command</h4>
<p>Here&#39;s an example (a real one, from a couple days ago when I was exploring Ollama) in which I tell Claude Code to take notes and then load the notes information at the beginning of the conversation:</p>
<ol>
<li><p>I&#39;m working on a new topic (in this case, Ollama) and at some point I notice that there is new information (for me)  that is important to write down. I ask Claude Code to write down the notes</p>
<p><picture>
<source type="image/avif" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/create_task_note-800.avif 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/create_task_note-1200.avif 1200w">
<source type="image/webp" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/create_task_note-800.webp 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/create_task_note-1200.webp 1200w">
<img src="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/create_task_note.png" width="1136" height="1057" loading="lazy" decoding="async" sizes="(max-width: 800px) 100vw, 800px" alt="Creating a new task note; Claude writes notes.md under the topic folder.">
</picture></p>
</li>
<li><p>When I start Claude Code, I can use a slash command (link to repo with slash command) that tells it which topics he should look for in the tasks: <code>claude &quot;/user:context ollama Modelfile&quot;</code></p>
</li>
<li><p>Then Claude Code starts and will look into its tasks/knowledge base for the topics (in this case, keywords are <code>ollama</code> and <code>Modelfile</code>) and, once it&#39;s finished, will have the correct information in context!</p>
<p><picture>
<source type="image/avif" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/user_context-800.avif 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/user_context-1200.avif 1200w">
<source type="image/webp" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/user_context-800.webp 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/user_context-1200.webp 1200w">
<img src="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/user_context.png" width="1200" height="681" loading="lazy" decoding="async" sizes="(max-width: 800px) 100vw, 800px" alt="/user:context loads matched notes and summarizes key points.">
</picture></p>
</li>
</ol>
<p>I know Claude Code has a <code>/resume</code> command to resume a conversation, but it&#39;s not the same as my <code>/user:context</code>: the default <code>/resume</code> only resumes conversations that happened in the same folder where we are launching Claude Code from; and it loads the entire thread, with all the messages and tokens: but sometimes I just want the summary (aka, the notes).</p>
<h3 id="knowledge-base-curator-flow">Knowledge base curator flow</h3>
<p>The tasks notes flow works great, but sometimes I want a more robust documentation file on certain topics. For example, if we&#39;re working on redesigning architecture on a system, it&#39;s important to move the notes into a more robust documentation file. </p>
<p>When I get to that point, I use the <a href="https://github.com/antoniocascais/claude-code-knowledge/blob/main/commands/review-knowledge.md.example" target="_blank"><code>review-knowledge</code> slash command</a>: it is configured with instructions on how to write down the knowledge base documents and it will call the <a href="https://github.com/antoniocascais/claude-code-knowledge/blob/main/agents/knowledge-base-curator.md" target="_blank"><code>knowledge-base-curator</code> agent</a>. </p>
<p>The agent will then process all the information and come up with a plan on what to write/modify in the knowledge base entry (or entries). Unlike the task notes, now I want to review what&#39;s written in these documents (the same way I would review documentation written by a human): so I configured the knowledge-base curator wait for me to accept the plan and only start writing the document afterwards.</p>
<p>Then I read the document (or the changes to an existing document), tell it if it should change something, and then Claude Code commits them.</p>
<p><picture>
<source type="image/avif" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/knowledge_review_example-800.avif 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/knowledge_review_example-1200.avif 1200w">
<source type="image/webp" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/knowledge_review_example-800.webp 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/knowledge_review_example-1200.webp 1200w">
<img src="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/knowledge_review_example.png" width="1200" height="667" loading="lazy" decoding="async" sizes="(max-width: 800px) 100vw, 800px" alt="Knowledge base curator proposes an enhancement plan based on task notes.">
</picture></p>
<h2 id="obsidian-integration">Obsidian integration</h2>
<p>If you opened the <a href="https://github.com/antoniocascais/claude-code-knowledge" target="_blank">claude-code-knowledge repository</a>, you might have noticed that Obsidian is mentioned in the CLAUDE.md file and also in the knowledge base related files.</p>
<p>From <a href="https://obsidian.md/" target="_blank">Obsidian website</a>:</p>
<blockquote>
<p>Obsidian is a flexible and secure app that lets you store, link, and publish your notes on any device. You can shape Obsidian with plugins, themes, and open file formats, and create your own personal Wikipedia or digital garden.</p>
</blockquote>
<p>I&#39;ve used Obsidian on and off for the last few years and it can be a great tool to write/edit/read Markdown files.</p>
<p>One of its advantages is that it can use built-in tools to build very cool visualizations. For example, in plain Markdown we have an integration flow like</p>
<pre><code class="language-mermaid">graph TD
    A[Command Execution] --&gt; B[Scope Detection]
    B --&gt; C[Content Analysis] 
    C --&gt; D[Plan Generation]
    D --&gt; E[User Approval]
    E --&gt; F[Agent Deployment]
    F --&gt; G[Specialized Execution]
    G --&gt; H[Results Summary]
</code></pre>
<p>Which Obsidian (with the help of <code>mermaid</code>) will transform into a visual flow!</p>
<p><picture>
<source type="image/avif" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_mardown_diagram-800.avif 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_mardown_diagram-1200.avif 1200w">
<source type="image/webp" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_mardown_diagram-800.webp 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_mardown_diagram-1200.webp 1200w">
<img src="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_mardown_diagram.png" width="933" height="789" loading="lazy" decoding="async" sizes="(max-width: 800px) 100vw, 800px" alt="Obsidian rendering Mermaid diagram showing workflow from Command Execution to Results Summary.">
</picture></p>
<p>And as the Knowledge base grows, you can take advantage of the Obsidian graph to see how the different documents are connected with each other:</p>
<p><picture>
<source type="image/avif" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_graph-800.avif 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_graph-1200.avif 1200w">
<source type="image/webp" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_graph-800.webp 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_graph-1200.webp 1200w">
<img src="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/obsidian_graph.png" width="1107" height="1084" loading="lazy" decoding="async" sizes="(max-width: 800px) 100vw, 800px" alt="Obsidian graph view showing interconnected knowledge base entries with nodes and links.">
</picture></p>
<p>In this graph, some nodes point to a document that actually exists and others point to nothing because there are no documents connected to that node. This is a feature, not a bug: it&#39;s to show to the user how different documents connect. If we click on the nodes that have no documents, a blank document will be created and we can start writing there.</p>
<p>To ensure that all these relations are properly setup, I explicitly tell the <a href="https://github.com/antoniocascais/claude-code-knowledge/blob/main/agents/knowledge-base-curator.md" target="_blank">knowledge-base curator agent</a> to take the links into consideration. And I do the same in the <a href="https://github.com/antoniocascais/claude-code-knowledge/blob/main/commands/review-knowledge.md.example" target="_blank">review knowledge slash command</a>.</p>
<p>With this setup, we have Claude Code taking notes that are already prepared to be open in Obsidian, taking advantage of its great features.</p>
<h2 id="codex-cli-bridge">Codex CLI bridge</h2>
<p>Besides Claude Code, from time to time I also use <a href="https://developers.openai.com/codex/cli" target="_blank">Codex CLI</a>. However, I felt that my experience with Codex CLI was worse because I didn&#39;t have my notes/knowledge curator flow.</p>
<p>So I decided to try using the exact same configurations for Codex CLI: moved the <code>CLAUDE.md</code> file and the folders <code>agents</code> and <code>commands</code> away from my <code>$HOME/.claude</code> folder and into a new folder in my system.</p>
<p>Then, in both Claude Code and Codex CLI I created symlinks to that new folder:</p>
<pre><code>$ ls -lgo $HOME/.claude
total 3168
lrwxrwxrwx  1      34 16. Sep 16:08 agents -&gt; $HOME/Documents/ai/agents
lrwxrwxrwx  1      37 16. Sep 16:47 CLAUDE.md -&gt; $HOME/Documents/ai/CLAUDE.md
lrwxrwxrwx  1      37 16. Sep 16:45 commands -&gt; $HOME/Documents/ai/commands/
</code></pre>
<pre><code>$ ls -lgo $HOME/.codex/AGENTS.md
lrwxrwxrwx 1 37 16. Sep 16:47 $HOME/.codex/AGENTS.md -&gt; $HOME/Documents/ai/CLAUDE.md
</code></pre>
<p>By doing this, I have both Claude Code and Codex CLI reading from the same instructions file. This avoids duplicated files and keeps everything more tidied up.</p>
<p>This works great for Claude Code (as it should, the files are the same, just located in another path), however it&#39;s not 100% compatible with Codex CLI: while Codex has built-in slash commands (like <code>/model</code>), it lacks official support for custom slash commands and subagents.</p>
<p>I haven&#39;t found a way to make the agents work, but for the slash commands topic I found a workaround: given that the slash commands are just extra prompts injected into the conversation, I figured that we can replace them by injecting the prompt via bash script.</p>
<p>For example, in order to load the context (basically the <code>/user:context</code> slash command mentioned earlier) I just need to call a custom <code>codex-context</code> function with the context topics:</p>
<p><picture>
<source type="image/avif" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/codex_context-800.avif 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/codex_context-1200.avif 1200w">
<source type="image/webp" srcset="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/codex_context-800.webp 800w, /assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/codex_context-1200.webp 1200w">
<img src="/assets/posts/2025-10-06-building-a-knowledge-base-with-claude-code-and-obsidian/codex_context.png" width="858" height="1205" loading="lazy" decoding="async" sizes="(max-width: 800px) 100vw, 800px" alt="Codex CLI helper loads context and summarizes with actionable bullets.">
</picture></p>
<p>This approach doesn&#39;t work great yet, so the <a href="https://github.com/antoniocascais/claude-code-knowledge/blob/main/bin/codex-commands.sh" target="_blank">bash script helper</a> is only published as a WIP.</p>
<p>Another issue that I haven&#39;t been able to solve was that, unlike Claude Code, Codex CLI <strong>always</strong> searches for context when I send it a new prompt. Sometimes I don&#39;t want it to search context, I&#39;m just using it for simple tasks. This is a bit annoying, but haven&#39;t had the time to look deeply into it.</p>
<h3 id="limitations">Limitations</h3>
<ul>
  <li><strong>No subagents:</strong> Codex CLI can’t invoke custom agents; only shared instructions in <code>CLAUDE.md</code> are reused.</li>
  <li><strong>No custom slash commands:</strong> Codex has some built-ins (e.g., <code>/model</code>) but doesn’t support user-defined commands.</li>
  <li><strong>Context search behavior:</strong> Codex currently searches context on each new prompt; there’s no toggle to skip it.</li>
  <li><strong>Parity gaps:</strong> The symlinked config unifies prompts, not capabilities—expect different tool behavior between apps.</li>
  <li><strong>Helper script is WIP:</strong> The bash workaround emulates commands but is brittle and may change.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>
<p>Having Claude Code acting as my personal notes writer is being very helpful to my workflow: saves me a lot of time and it also helps me get back into tasks when I&#39;m multitasking (which is the life of a DevOps engineer, always handling multiple tasks at the same time).</p>
<p>The knowledge base feature also has great potential, but I haven&#39;t had the chance to test it extensively in ever-growing systems. However, I see this as something that Claude Code (or any other AI CLI tool) can do. If not now, soon.</p>
<p>I believe that by configuring our AI tools to keep information in text files we can extract valuable help in a format that we really understand well: the text format.</p>

<style>
  /* Minimal lightbox */
  .img-lightbox::backdrop { background: rgba(0,0,0,.75); }
  .img-lightbox {
    border: 0; padding: 0; margin: 0;
    width: 100vw; height: 100vh;
    background: transparent;
  }
  .img-lightbox .container {
    display: grid; place-items: center;
    width: 100vw; height: 100vh;
    padding: 2rem;
  }
  .img-lightbox .container picture img {
    max-width: 90vw; max-height: 90vh;
    width: auto; height: auto;
  }
  .img-zoomable { cursor: zoom-in; }
  .img-lightbox .close {
    position: fixed; top: .75rem; right: .75rem;
    font-size: 1.5rem; line-height: 1;
    background: rgba(0,0,0,.6); color: #fff; border: 0; border-radius: .5rem;
    padding: .35rem .6rem; cursor: pointer;
  }
</style>

<dialog id="img-lightbox" class="img-lightbox" aria-label="Image viewer">
  <button class="close" aria-label="Close">×</button>
  <div class="container"></div>
</dialog>

<script>
(() => {
  const dlg = document.getElementById('img-lightbox');
  const container = dlg.querySelector('.container');
  const closeBtn = dlg.querySelector('.close');

  // Make every picture clickable
  document.querySelectorAll('article .post-content picture').forEach(pic => {
    const img = pic.querySelector('img');
    if (!img) return;
    img.classList.add('img-zoomable');
    img.addEventListener('click', () => {
      // Clone the <picture> so AVIF/WebP fallback still works in the lightbox
      const clone = pic.cloneNode(true);
      const cimg = clone.querySelector('img');

      // Remove loading hints and sizing so it can grow freely
      cimg.removeAttribute('loading');
      cimg.removeAttribute('decoding');
      cimg.removeAttribute('sizes');

      // Inject and open
      container.innerHTML = '';
      container.appendChild(clone);
      dlg.showModal();
    });
  });

  // Close interactions
  closeBtn.addEventListener('click', () => dlg.close());
  dlg.addEventListener('click', (e) => {
    // click outside content closes
    if (!e.composedPath().includes(container)) dlg.close();
  });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && dlg.open) dlg.close();
  });
})();
</script>

